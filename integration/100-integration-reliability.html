---
title: 100 % Integrationszuverlässigkeit
description: 'In diesem Thema werden die Gründe erläutert, aus denen Sie möglicherweise keine Verbindung zu Zencoder herstellen können, und wie Sie eine zuverlässige Integration sicherstellen.'
parent: Integration
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Overview">Überblick</h2>

    <p>Zencoder ist für die meisten unserer Kunden eine wesentliche Software-Abhängigkeit. Und obwohl wir eine 100% ige Verfügbarkeit anstreben, kann es vorkommen, dass Sie keine Verbindung zu Zencoder herstellen können:</p>

    <p>Wenn dies passiert und Zencoder ausgefallen ist, erhält Ihre Anwendung in der Regel eine' Antwort „503 Service nicht verfügbar“ von Zencoder, aber Sie können einen anderen Fehler (z. B. einen 500) erhalten. Wenn Sie Ihr API-Zinslimit überschritten haben, erhalten Sie eine' Antwort „403 Rate Limit überschritten“.</p>

    <p>Die gute Nachricht: Da die Videokodierung ein asynchroner Prozess ist, können Sie Ihre Anwendung so erstellen, dass keine Ausfallzeiten oder Probleme im Zusammenhang mit unserer Verfügbarkeit auftreten. Wenn Sie dies tun, ist das schlimmste Szenario, dass Ihre Jobs etwas länger dauern. Es treten jedoch keine Fehler auf. Wir empfehlen Ihnen dringend, dies zu tun.</p>

    <p>Um es stärker auszudrücken, <strong>Wenn Sie Wert auf Zuverlässigkeit legen, sollten Sie diesen Integrationsansatz befolgen</strong> - für Zencoder oder für jede kritische API, in die Sie integrieren.</p>

    <ul>
      <li>Unser Service kann durch Probleme bei einem Upstream-Anbieter (z. B. Amazon Web Services) beeinträchtigt werden.</li>
      <li>Gelegentlich müssen wir Systemwartungen durchführen, die vorübergehende Ausfallzeiten erfordern</li>
      <li>Sie haben Ihre übertroffen <a href="/general-information/faq-rate-limiting.html">API-Ratenlimit</a></li>
      <li>usw.</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Reliable_app_integration">Zuverlässige App-Integration</h2>

    <ol>
      <li>Fügen Sie ein <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#secondary-url">Sekundäre URL</a> als Backup für den Fall, dass der Upload an Ihren primären Speicherort fehlschlägt.</li>
      <li>Wenn Sie einen nicht erfolgreichen Antwortcode von Zencoder erhalten - im Grunde genommen etwas anderes als 200 oder 201 - <strong>scheitern Sie nicht den Job</strong>. Ein Antwortcode von 503 bedeutet nicht, dass Ihr Video nicht verarbeitet werden kann. Es bedeutet nur, dass Zencoder vorübergehend nicht verfügbar ist.</li>
      <li>Wenn Sie eine bekommen <strong>Verbindungsfehler</strong> Wenn Sie versuchen, eine Verbindung zu Zencoder herzustellen, gehen Sie genauso vor.</li>
      <li>Ähnlich, <strong>Schließen Sie Ihre API-Anforderungen in ein Timeout ein</strong>. Wir empfehlen eine Zeitüberschreitung von 30 Sekunden. Zencoder reagiert normalerweise in weniger als einer Sekunde, daher sind 30 Sekunden normalerweise ausreichend Zeit.</li>
      <li>In allen drei Fällen - wenn Sie einen nicht erfolgreichen Antwortcode erhalten, keine Verbindung herstellen können oder die API-Anforderung eine Zeitüberschreitung aufweist - <strong>Kennzeichnen Sie den Job als "ausstehend".</strong></li>
      <li>Regelmäßig, <strong>Senden Sie alle Jobs in der 'ausstehenden' </strong>Zustand . Sie können dies beispielsweise jede Minute mit cron tun.</li>
    </ol>
    <p>Sobald die Jobs erneut gesendet wurden, verhält sich alles wie gewohnt. Auf diese Weise dauert eine fehlgeschlagene Auftragsübermittlung nur ein wenig länger, anstatt Probleme für Ihre Anwendung oder Ihre Benutzer zu verursachen.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Pseudocode">Pseudocode</h2>

    <p>OK, das ist also kein Pseudocode - es ist Ruby. Aber Ruby ist ziemlich einfach zu lesen.</p>

    <ol>
      <li>Stellen Sie sich eine Videos-Tabelle vor, die diese Spalten enthält. (Es wird offensichtlich mehr enthalten, einschließlich Spalten zum Speichern einer Zencoder-Job-ID und einer Zencoder-Ausgabedatei-ID.)
        <pre class="line-numbers">
<code class="language-ruby" translate="No">create_table :videos do |t|
t.string  :state
t.integer :lock_version
t.index   :state
end</code></pre>
      </li>
      <li>Ein Video sollte eine Zustandsmaschine mit den folgenden Zuständen enthalten:
        <ul>
          <li>ausstehend (noch nicht bei Zencoder eingereicht)</li>
          <li>einreichen (derzeit an Zencoder einreichen)</li>
          <li>Transcoding (erfolgreich an Zencoder eingereicht)</li>
          <li>fertig (Zencoder hat die Transcodierung beendet und die Arbeit ist erledigt)</li>
          <li>fehlgeschlagen (Zencoder konnte das Video nicht transkodieren)</li>
        </ul>
      </li>
      <li>Wenn ein neues Video aufgenommen wird, speichern Sie das Video im' Status „Senden“ und lösen Sie einen Hintergrundjob aus, um das Video an Zencoder zu senden.
        <pre class="line-numbers">
<code class="language-ruby" translate="No"># got a new video!
video = Video.new(params)
video.state = "submitting"
video.save!
submit_to_zencoder(video)</code></pre>

        <p>Sie sollten die Methode submit_to_zencoder wirklich als Hintergrund verwenden. In Ruby mit DelayedJob könnte dies folgendermaßen aussehen:</p>

        <pre class="line-numbers">
<code class="language-ruby" translate="No">delay.submit_to_zencoder(video)</code></pre>

        <p>Aber wir bleiben bei unserem <code translate="No">submit_to_zencoder(video)</code> Methode zum Beispiel Zwecke.</p>
      </li>
      <li>Das <code translate="No">submit_to_zencoder</code> Funktion sieht ungefähr so aus. Dies sollte asynchron im Hintergrund ausgeführt werden.
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def submit_to_zencoder(video)
begin
response = Zencoder::Job.create(attributes, :timeout =&gt; 30_000)
if response.code == 201
video.state = "transcoding"
else
video.state = "pending"
end

video.save!

# Rescue any connection error. Our plugin abstracts these as
# Zencoder::HTTPError.
#
# If you're not using the Zencoder plugin, this includes things
# like Errno::ECONNRESET, Errno::ETIMEDOUT, Errno::ECONNREFUSED,
# Errno::EHOSTDOWN, and SocketError.

rescue Timeout::Error, Zencoder::HTTPError
video.state = "pending"
video.save!
end
end</code></pre>
      </li>
      <li>Versuchen Sie immer wieder - z. B. jede Minute - Jobs, die sich im' Status „Ausstehend“ befinden, erneut einzureichen.
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def resubmit_pending_jobs
Video.where(:state =&gt; "pending").find_each do |video|
begin
video.state = "submitting"
video.save!

submit_to_zencoder(video)
rescue ActiveRecord::StaleObjectError
end
end
end
</code></pre>

        <p>Durch das Hinzufügen einer 'lock_version' -Spalte zur Videosetabelle führen wir ein optimistisches Sperren ein. Dies bedeutet, dass, wenn der Datensatz zwischen dem aktualisiert wird <code translate="No">Video.find</code> Abfrage und <code translate="No">video.save</code> Der Auftrag wird nicht an Zencoder gesendet. Dadurch wird verhindert, dass der Auftrag zweimal versehentlich an Zencoder gesendet wird. Sie können pessimistische Sperren oder Datenbanksperren oder eine andere Sperrmethode verwenden, um dasselbe zu erreichen.</p>

        <h2>So einfach ist das…</h2>

        <p>Alles in allem ist dies ein ziemlich einfacher Ansatz, um eine 100% ige Integrationszuverlässigkeit zwischen Zencoder und Ihrer Anwendung sicherzustellen. Es sind ein paar Schritte mehr als nur das naive Einreichen eines Jobs. Es stellt jedoch sicher, dass Ihre App zuverlässig ausgeführt wird, unabhängig davon, was passiert - ob es sich um eine gelegentliche Zeitüberschreitung, unerwartete Ausfallzeiten bei Zencoder oder geplante Wartungsarbeiten handelt.</p>
      </li>
    </ol>
  </section>
</article>