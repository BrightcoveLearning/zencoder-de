---
title: Transmuxing Guide
description: 'In diesem Thema wird das <strong>Transmuxing erklärt</strong>, ein Prozess, mit dem Sie Ihre Videos in MP4 codieren und diese dann auch als HLS-Ausgaben neu verpacken können.'
parent: Encoding Guides
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Overview">Überblick</h2>

    <p>Mit Zencoder können Sie Ihre Videos in MP4 codieren und diese dann auch als HLS-Ausgänge neu verpacken. Dies wird als "Transmuxing" (anstatt Transcodieren) bezeichnet. Durch Transmuxing werden vorhandene MP4-Videos in die für HTTP Live Streaming (HLS) erforderlichen MPEG TS-Segmente neu gepackt, ohne dass die Videodateien neu codiert werden müssen. Mithilfe abhängiger Ausgaben können Sie Ihre H.264-Dateien sowie die segmentierten Dateien in einem einzigen Job erstellen und so eine schnellere Abwicklung zu geringeren Kosten erzielen. Transmux-Ausgänge werden mit 1/4 der Codierungskosten berechnet. Der resultierende Job erstellt 6 Ausgaben - 2 werden zum regulären Tarif Ihres Kontos berechnet, 3 transmuxierte Dateien zu 1/4 der Codierungskosten und 1 kostenlose Wiedergabeliste.</p>

    <p>Dazu erstellen Sie einen einzelnen Job mit zwei Hauptausgabesätzen (plus den Wiedergabelisten). Der erste Satz von Ausgängen sind normale H.264/AAC-MP4-Dateien mit einigen speziellen Einstellungen, damit sie als Quelldateien für HLS-Ausgaben arbeiten können. Der zweite Satz von Ausgängen verwendet diese MP4-Dateien als "Quell" -Eingänge und überträgt ihren Inhalt auf HLS-Ausgänge. Da es sich um abhängige Ausgaben handelt, warten sie, bis die entsprechende Quelle fertig ist, bevor sie für die Verarbeitung geplant werden.</p>

    <p>Der Hauptteil des Prozesses ist die Verwendung <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a> einer neuen Option in V2 der Zencoder-API. Die Quelle weist eine Ausgabe an, anstelle der Eingabedatei die Datei zu verwenden, die von einer anderen Ausgabe im Job für die Verarbeitung erstellt wurde. In dieser Situation erstellt Zencoder H.264-Dateien basierend auf der Eingabedatei mit den angeforderten Bitraten. Wenn jede dieser Ausgaben beendet ist, wird aus der Ausgabe eine segmentierte Version erstellt.</p>

    <aside class="bcls-aside bcls-aside--information">Hinweis: Es gibt keine Möglichkeit, sicherzustellen, dass die Wiedergabe reibungslos verläuft, wenn Sie <strong>Kombinieren Sie Transmux- und Transcode-Ausgänge in einer Wiedergabeliste</strong>. Es empfiehlt sich, dass die Formatvarianten auf die gleiche Weise codiert werden müssen.</aside>
  </section>
  <section class="bcls-section">
    <h2 id="h264_outputs">Die H.264-Ausgänge</h2>

    <p>Wir beginnen mit der Erstellung von 2 H.264-Dateien, die auf hohe und niedrige Bitraten abzielen.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "label": "low",
    "format": "mp4",
    "video_bitrate": 200,
    "decoder_bitrate_cap": 300,
    "decoder_buffer_size": 1200,
    "audio_sample_rate": 44100,
    "height": "288",
    "url": "s3://example-bucket/low.mp4",
    "h264_reference_frames": 1,
    "forced_keyframe_rate": "0.1",
    "audio_bitrate": 56,
    "decimate": 2
},
{
    "label": "high",
    "format": "mp4",
    "video_bitrate": 1000,
    "decoder_bitrate_cap": 1500,
    "decoder_buffer_size": 6000,
    "audio_sample_rate": 44100,
    "height": "432",
    "url": "s3://example-bucket/high.mp4",
    "h264_reference_frames": "auto",
    "h264_profile": "main",
    "forced_keyframe_rate": "0.1",
    "audio_bitrate": 56
}</code></pre>

    <p>Die aus diesen Ausgaben resultierenden Dateien können auf einer Vielzahl von Geräten abgespielt werden. Jedes zielt auf eine andere Bitrate und Auflösung ab, sodass Benutzern die entsprechende Datei gesendet werden kann. Jedes eignet sich auch zur Segmentierung für HTTP Live Streaming und als adaptiver Bitraten-Stream.</p>

    <p>Einige Optionen in der obigen Anfrage zu beachten:</p>

    <ul>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-frame-rate.html#forced-keyframe-rate"><code translate="No">forced_keyframe_rate</code></a> auf 0,1. Dadurch wird das Video alle 10 Sekunden mit einem Keyframe versehen. Die segmentierten Dateien sind 10 Sekunden lang, wodurch sichergestellt wird, dass dort jedes Segment mit einem Keyframe beginnt.</li>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-bitrate-cap"><code translate="No">decoder_bitrate_cap</code></a> ist auf das 1,5-fache der Zielbitrate der Datei eingestellt. <a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-buffer-size"><code translate="No">decoder_buffer_size</code></a> ist auf das 3,5-fache bis 5-fache der Zielbitrate der Datei eingestellt. Diese Einstellungen tragen dazu bei, eine konsistente Bitrate in der gesamten Datei beizubehalten, sodass die segmentierten Segmente in Größe und Bitrate nicht zu stark variieren.</li>
    </ul>
    <p>Nachdem die H.264-Dateien erstellt wurden, können der Anforderung zum Erstellen segmentierter HTTP Live Streaming-Dateien aus der Quelle zusätzliche Ausgaben hinzugefügt werden, ohne dass eine zusätzliche Codierung erforderlich ist.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Segmented_Outputs">Segmentierte Ausgaben</h2>

    <p>Jedes der oben genannten H.264-Video- und Audioausgänge verfügt über <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#label"><code translate="No">labels</code></a> in ihren API-Optionen. Diese Etiketten können in Verbindung mit dem verwendet werden <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a> Option, um Zencoder anzuweisen, das von der Ausgabe erstellte Video mit der angegebenen Bezeichnung anstelle der Eingabedatei zu verwenden. Da die H.264-Dateien bereits gute Einstellungen für HLS haben, ist keine zusätzliche Codierung erforderlich.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "source": "low",
    "format": "ts",
    "copy_audio": "true",
    "copy_video": "true",
    "url": "s3://example-bucket/hls-low/hls-low.m3u8",
    "label": "hls-low",
    "type": "segmented"
}
{
    "source": "high",
    "format": "ts",
    "copy_audio": "true",
    "copy_video": "true",
    "url": "s3://example-bucket/hls-high/hls-high.m3u8",
    "label": "hls-high",
    "type": "segmented"
}
{
    "streams": [
    {
        "path": "hls-low/hls-low.m3u8",
        "bandwidth": 256
    },
    {
        "path": "hls-high/hls-high.m3u8",
        "bandwidth": 1056
    }
    ],
    "type": "playlist",
    "url": "s3://example-bucket/playlist.m3u8"
}</code></pre>

    <p>Die aus diesen Ausgaben resultierenden Dateien sind segmentierte Ausgaben, die auf unterschiedliche Bandbreiten abzielen, sowie eine Wiedergabelistendatei, damit das Wiedergabegerät die verfügbaren Streams kennt.</p>

    <p>Jede segmentierte Ausgabe enthält die <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a> und gibt einen der zuvor aufgeführten Ausgänge an. Dazu gehört auch die <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-audio"><code translate="No">copy_audio</code></a> und <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-video"><code translate="No">copy_video</code></a> Optionen, die Zencoder anweisen, die Audio- und Videostreams aus der Quelldatei zu verwenden und sie in den neuen Container neu zu packen, anstatt sie zu transkodieren. Schließlich geben die Ausgänge auch ein <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#type"><code translate="No">type</code></a> segmentiertes und ein <a href="/encoding-settings/formats-codecs/encoding-settings-format-and-codecs.html#format"><code translate="No">format</code></a> von ts, plus a <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#url"><code translate="No">url</code></a> mit einer Erweiterung von .m3u8, damit Zencoder weiß, segmentierte HLS-Dateien zu erstellen.</p>

    <p>Schließlich wird auch eine Wiedergabeliste generiert, die auf jede der segmentierten Ausgaben verweist. Beachten Sie, dass die erste Datei, auf die in der Wiedergabeliste verwiesen wird, das Video mit niedriger Bitrate ist. Das Gerät, das das Video abspielt, lädt im Allgemeinen den ersten in der Wiedergabeliste aufgelisteten Stream und wechselt bei Bedarf zu anderen Streams. Dies bedeutet, dass in den ersten 10 Sekunden der Wiedergabe dieser Stream verwendet wird. Danach verfügt das Gerät über genügend Informationen, um den geeigneten Stream für die Wiedergabe auszuwählen.</p>

    <p><strong>ANMERKUNGEN</strong></p>

    <ul>
      <li>Die HLS-Wiedergabelistengenerierung verwendet derzeit keine Informationen aus den anderen Ausgaben im Job, sondern ist lediglich eine Möglichkeit, auf einfache Weise eine korrekt formatierte Wiedergabeliste mit adaptiver Bitrate zu erstellen und zusammen mit den anderen Dateien hochladen zu lassen.</li>
      <li>Während iOS-Geräte die erstellte adaptive Bitraten-Wiedergabeliste wiedergeben, wird VLC dies aufgrund von Fehlern bei der Verarbeitung relativer URLs nicht tun. Es wird nach den Segmentdateien im selben Verzeichnis wie die Wiedergabelistendatei und nicht im Verzeichnis der Manifestdatei gesucht.</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Full_request">Vollständige Anfrage</h2>

    <p>Nachdem wir alle wichtigen Ausgabeabschnitte durchgesehen haben, lassen Sie uns sie zu einer einzigen API-Anforderung zusammenfassen.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "s3://zencodertesting/test.mov",
    "outputs": [
    {
        "label": "low",
        "format": "mp4",
        "video_bitrate": 200,
        "decoder_bitrate_cap": 300,
        "decoder_buffer_size": 1200,
        "audio_sample_rate": 44100,
        "height": "288",
        "url": "s3://example-bucket/low.mp4",
        "h264_reference_frames": 1,
        "forced_keyframe_rate": "0.1",
        "audio_bitrate": 56,
        "decimate": 2
    },
    {
        "label": "high",
        "format": "mp4",
        "video_bitrate": 1000,
        "decoder_bitrate_cap": 1500,
        "decoder_buffer_size": 6000,
        "audio_sample_rate": 44100,
        "height": "432",
        "url": "s3://example-bucket/high.mp4",
        "h264_reference_frames": "auto",
        "h264_profile": "main",
        "forced_keyframe_rate": "0.1",
        "audio_bitrate": 56
    },
    {
        "source": "low",
        "format": "ts",
        "copy_audio": "true",
        "copy_video": "true",
        "url": "s3://example-bucket/hls-low/hls-low.m3u8",
        "label": "hls-low",
        "type": "segmented"
    }
    {
        "source": "high",
        "format": "ts",
        "copy_audio": "true",
        "copy_video": "true",
        "url": "s3://example-bucket/hls-high/hls-high.m3u8",
        "label": "hls-high",
        "type": "segmented"
    }
    {
        "streams": [
        {
            "path": "hls-low/hls-low.m3u8",
            "bandwidth": 256
        },
        {
            "path": "hls-high/hls-high.m3u8",
            "bandwidth": 1056
        }
        ],
        "type": "playlist",
        "url": "s3://example-bucket/playlist.m3u8"
    }
    ]
}</code></pre>
  </section>
</article>