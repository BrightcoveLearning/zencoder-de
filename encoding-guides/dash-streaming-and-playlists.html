---
title: Beschreibung der DASH-Streaming- und Wiedergabelisten: In diesem Thema wird erläutert, wie Sie Jobs für die DASH-Ausgabe konfigurieren.
parent: Encoding Guides
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Introduction">Einführung</h2>

    <aside class="bcls-aside bcls-aside--information">Beachten Sie, dass Dash nicht mit Livestreams mit Zencoder kompatibel ist.</aside>
    <p>Da DASH kein bestimmtes Videoformat, Codec oder datenunabhängiges Verpackungsformat (z. B. Zip) ist, haben wir eine neue Option mit dem Namen eingeführt <a href="/encoding-settings/assets/encoding-settings-clips.html#streaming-delivery-format"><code translate="No">streaming_delivery_format</code></a>um festzulegen, dass die Mediendateien nach einem bestimmten Standard strukturiert / formatiert werden sollen. Wählen Sie "Strich" als <code translate="No">streaming_delivery_format</code> ändert einige Standardoptionen für die Kompatibilität mit DASH und legt die Ausgabemediendateien in einer Verzeichnisstruktur ab, die den DASH-Anforderungen entspricht. DASH-Medienausgänge müssen ebenfalls vorhanden sein <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#type"><code translate="No">type</code></a> Stellen Sie "segmentiert" ein, um sicherzustellen, dass das Medium für das DASH-Streaming vorbereitet ist.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/sbr/rendition.mpd"
    }
    ]
}</code></pre>

    <p>Details für Ausgänge mit <code translate="No">streaming_delivery_format</code> auf "dash" setzen:</p>

    <ul>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-frame-rate.html#fixed-keyframe-interval"><code translate="No">fixed_keyframe_interval</code></a> wird auf true gesetzt.</li>
      <li><a href="/encoding-settings/assets/encoding-settings-clips.html#segment-seconds"><code translate="No">segment_seconds</code></a> wird standardmäßig auf 2 gesetzt.</li>
      <li>Das Standardformat ist <code translate="No">m4f</code> (mit einem <code translate="No">mpd</code> Manifestdatei)</li>
    </ul>
    <p>Dateistruktur für segmentierte DASH-Ausgaben:</p>

    <ul>
      <li>Das <code translate="No">mpd</code> Die Manifestdatei befindet sich auf der Stammebene der Ausgabe.</li>
      <li>Die Audio- und Videomedien haben jeweils ein eigenes Unterverzeichnis -<code translate="No">audio/und</code>"<code translate="No">video/1</code>" bzw. „.</li>
      <li>In jedem dieser Verzeichnisse wird es ein "<code translate="No">init.mp4</code>" mit den Initialisierungsdaten geben.</li>
      <li>Die Mediendaten befinden sich in Dateien mit dem Namen "<code translate="No">seg-N.m4f</code>" (wobei N bei Null beginnt und für jedes Segment zunimmt).</li>
    </ul>
    <p>DASH gibt mit dem aus <a href="/encoding-settings/assets/encoding-settings-clips.html#streaming-delivery-profile"><code translate="No">streaming_delivery_profile</code></a> Bei der Einstellung "on_demand" werden fragmentierte Mediendateien anstelle von Segmenten verwendet:</p>

    <ul>
      <li>Das <code translate="No">mpd</code> Die Manifestdatei befindet sich auf der Stammebene der Ausgabe.</li>
      <li>Die Audio- und Videomedien sind jeweils eine einzelne Datei im selben Verzeichnis wie das Manifest.</li>
      <li>Die Mediendateien werden ähnlich wie das Manifest benannt, aber gegebenenfalls werden Suffixe<code translate="No">-audio</code><code translate="No">-video</code>" oder" hinzugefügt.</li>
    </ul>
    <p>Unterstützte DASH-Konfigurationen:</p>

    <ul>
      <li>Unterstützte Formate: <code translate="No">m4f</code> und <code translate="No">webm</code></li>
      <li>Unterstützte Videocodecs: <code translate="No">h264</code> <code translate="No">hevc</code>, <code translate="No">vp8</code>, und <code translate="No">vp9</code></li>
      <li>Unterstützte Audio-Codecs: <code translate="No">aac</code> <code translate="No">ac3</code>, <code translate="No">eac3</code>, und <code translate="No">vorbis</code></li>
      <li>Ausgaben im "<code translate="No">webm</code>" -Format unterstützen derzeit nur das „on_demand“ <code translate="No">streaming_delivery_profile</code></li>
      <li>Ausgänge im "<code translate="No">webm</code>" -Format unterstützen derzeit kein DRM</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Multiple_Bitrates">Mehrere Bitrate</h2>

    <p>Von Zencoder generierte DASH-Ausgaben haben die erforderliche Struktur, um selbst abgespielt zu werden. Um jedoch wirklich von solchen Streaming-Übermittlungsoptionen zu profitieren, sollten Sie mehrere Versionen mit unterschiedlichen Bitraten (Wiedergaben) zusammen mit einer Ausgabe vom Typ "Wiedergabeliste" generieren, in der die Wiedergaben aufgelistet sind so dass ein Spieler die Bitraten je nach den aktuellen Netzwerkbedingungen nach Bedarf hoch- / runterschalten kann. Die Wiedergabelistenausgabe ist eine abhängige Ausgabe. Das heißt, sie verweist auf die anderen Ausgaben anhand ihrer Bezeichnung und verwendet Daten aus diesen Ausgaben, um die endgültige Wiedergabe der Wiedergabeliste zu generieren. Beachten Sie, dass Sie darauf achten müssen, die Stream-Pfade in der Wiedergabelistenausgabe so festzulegen, dass sie relative Pfade zum Speicherort der Wiedergabedateien sind.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "dash-1200",
        "streaming_delivery_format": "dash",
        "video_bitrate": 1200,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/1200k/rendition.mpd"
    },
    {
        "label": "dash-700",
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/700k/rendition.mpd"
    },
    {
        "label": "dash-400",
        "streaming_delivery_format": "dash",
        "video_bitrate": 400,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/400k/rendition.mpd"
    },
    {
        "streaming_delivery_format": "dash",
        "type": "playlist",
        "url": "s3://mybucket/dash-examples/mbr/manifest.mpd",
        "streams": [
        { "source": "dash-1200", "path": "1200k" },
        { "source": "dash-700",  "path": "700k" },
        { "source": "dash-400",  "path": "400k" }
        ]
    }
    ]
}</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="Encryption">Verschlüsselung</h2>

    <p>Zencoder unterstützt auch das Generieren von CENC-verschlüsselten DASH-Ausgaben mit den erforderlichen Headern für die Integration in Marlin- oder Playready-Lizenzserver. Geben Sie für jede Ausgabe einfach einen Hash von drm-Optionen an, einschließlich der <a href="/encoding-settings/content-protection/encoding-settings-drm.html#method"><code translate="No">method</code></a> <a href="/encoding-settings/content-protection/encoding-settings-drm.html#key-id"><code translate="No">key_id</code></a> und <a href="/encoding-settings/content-protection/encoding-settings-drm.html#content-key"><code translate="No">content_key</code></a>. Das <code translate="No">key_id</code> und <code translate="No">content_key</code> sollte entweder von Ihrem DRM-Anbieter abgerufen oder vorgeneriert und an Ihren DRM-Anbieter gesendet werden. Sobald Sie diese Schlüssel haben, lautet die Zencoder-API-Struktur für eine einzelne Wiedergabe:</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/sbr/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    }
    ]
}</code></pre>

    <p>Der Inhalt wird mit dem verschlüsselt <code translate="No">content_key</code>, und die <code translate="No">.mpd</code> Manifestdatei enthält die <code translate="No">key_id</code> in seinen Headern. Um sicherzustellen, dass diese Ausgabe wiedergegeben werden kann, sind außerdem Header erforderlich, die angeben, wie die Ausgabe abgerufen werden soll <code translate="No">content_key</code>. Bei einer DASH-Codierung mit mehreren Bitraten müssen diese Header nur zur Wiedergabelistenausgabe hinzugefügt werden, können aber auch zu jeder Wiedergabe hinzugefügt werden, sodass die Wiedergabe einzeln abspielbar ist. Dies erfolgt durch Hinzufügen eines oder mehrerer DRM-Schemas:</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/sbr/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0",
            "schemas": [
            { "type": "marlin" },
            { "type": "playready", "license_acquisition_url": "https://playready.example.com/license_server/" }
            ]
        }
    }
    ]
}</code></pre>

    <p>Wir können dies dann zusammenfassen, um einen DRM-verschlüsselten DASH-Job mit mehreren Bitraten zu erstellen:</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "dash-1200",
        "streaming_delivery_format": "dash",
        "video_bitrate": 1200,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/1200k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "label": "dash-700",
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/700k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "label": "dash-400",
        "streaming_delivery_format": "dash",
        "video_bitrate": 400,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/400k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "streaming_delivery_format": "dash",
        "type": "playlist",
        "url": "s3://mybucket/dash-examples/mbr/manifest.mpd",
        "streams": [
        { "source": "dash-1200", "path": "1200k" },
        { "source": "dash-700",  "path": "700k" },
        { "source": "dash-400",  "path": "400k" }
        ],
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0",
            "schemas": [
            { "type": "marlin" },
            { "type": "playready", "license_acquisition_url": "https://playready.example.com/license_server/" }
            ]
        }
    }
    ]
}
</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="Transmuxing">Transmuxing</h2>

    <p>Das Generieren mehrerer Formate eines Videos kann natürlich teuer und verschwenderisch werden. Daher unterstützt Zencoder das Umpacken derselben codierten Streams in verschiedene Formate (Transmuxing genannt) mithilfe von <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-video"><code translate="No">copy_video</code></a> und <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-audio"><code translate="No">copy_audio</code></a> Optionen. Ausgänge, für die das Video nicht codiert, sondern transmuxiert wird, werden mit 1/4 der regulären Dauer aufgeladen. Wenn Sie also mehrere Formate desselben Videos erstellen möchten (z. B. MP4, HLS und DASH), können Sie zuerst die MP4-Version jeder Bitrate codieren und diese Ausgänge dann übertragen, um die HLS- und DASH-Versionen zu erstellen. (Beachten Sie, dass wir das Transmuxen von einem segmentierten Format nicht unterstützen, da das Video kein einzelner Stream mehr ist.)</p>

    <p>Um sicherzustellen, dass der MP4 gemäß den Einschränkungen der nachfolgenden segmentierten Streaming-Formate vorbereitet wird, verwenden Sie auch die <a href="/encoding-settings/assets/encoding-settings-clips.html#prepare-for-segmenting"><code translate="No">prepare_for_segmenting</code></a> Option für den MP4-Ausgang. Dadurch werden die Standardwerte für Keyframes und Untertitel beim Codieren des Videostreams des MP4 gesteuert, um sicherzustellen, dass er anschließend mit der Übertragung in segmentierte Formate kompatibel ist.</p>

    <p>Die Verwendung des MP4 als Quelle für die Transmux-Ausgänge funktioniert ähnlich wie die Wiedergabelistenausgänge. Sie geben eine Quelloption an, die mit der Bezeichnung einer anderen Ausgabe übereinstimmt. Diesmal ist sie jedoch Teil der Optionen auf Hauptebene für die Ausgabe und nicht im Stream-Hash.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "mp4-700k",
        "prepare_for_segmenting": ["hls", "dash"],
        "video_bitrate": 700,
        "url": "s3://mybucket/transmux-examples/sbr/video.mp4"
    },
    {
        "source": "mp4-700k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/transmux-examples/sbr/hls/video.m3u8"
    },
    {
        "source": "mp4-700k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/transmux-examples/sbr/dash/video.mpd"
    }
    ]
}</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="Optimizing_for_delivery">Optimierung für die Lieferung</h2>

    <p>Da DASH für die Streaming-Übermittlung vorgesehen ist, empfehlen wir, die Spitzen der Bitraten in jeder Wiedergabe zu steuern, um zu vermeiden, dass der Player erneut puffert oder auf Codierungen mit niedrigerer Bitrate umschaltet. Die Optionen, die die Variabilität des codierten Streams je nach dem steuern, was der Decoder/Player handhaben kann, sind</p>

    <ul>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-bitrate-cap"><code translate="No">decoder_bitrate_cap</code></a></li>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-buffer-size"><code translate="No">decoder_buffer_size</code></a></li>
    </ul>
    <aside class="bcls-aside bcls-aside--information">Notiz: <a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#max-video-bitrate"><code translate="No">max_video_bitrate</code></a> dient zum Steuern der maximalen durchschnittlichen Bitrate über den gesamten Stream und ist nicht für Streaming-Inhalte geeignet.</aside>
    <p>Unsere allgemeine Empfehlung ist zu setzen <code translate="No">decoder_bitrate_cap</code> auf die maximal für den Videostream verfügbare Bitrate. Denken Sie daran, dass Sie das Audio sowie einen gewissen Overhead für das Dateiformat berücksichtigen müssen. Das <code translate="No">decoder_buffer_size</code> soll technisch mit dem verfügbaren Videopufferspeicher auf dem Decodiergerät übereinstimmen, wird jedoch häufig besser verwendet, um zu steuern, wie viel Inhalt vorgepuffert werden kann. Es funktioniert als Vielfaches der <code translate="No">decoder_bitrate_cap</code>, so dass zum Beispiel bei <code translate="No">decoder_bitrate_cap</code> 500 (Kilobits pro Sekunde) und <code translate="No">decoder_buffer_size</code> war 1000 (Kilobits), dann konnte der Puffer Video im Wert von 2 Sekunden speichern. Wir empfehlen auch die Einstellung der <a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#video-bitrate"><code translate="No">video_bitrate</code></a> etwas niedriger als die <code translate="No">decoder_bitrate_cap</code> Dadurch kann der Encoder mehr Daten zum Codieren komplexer Szenen und weniger Daten für einfachere Szenen verwenden. Ein anständiger Ausgangspunkt wäre, bis zu 10% des Overheads für das Dateiformat anzunehmen und das festzulegen <code translate="No">video_bitrate</code> 10% niedriger als die <code translate="No">decoder_bitrate_cap</code> und das Puffern von ca. 1,5 Sekunden Video.</p>

    <p>Angenommen, dem Kunden steht eine 1000-Kbit / s-Verbindung zur Verfügung:</p>

    <ul>
      <li>1000 * 0,90 = 900 Kbit / s verfügbar, nachdem 10% für den Format-Overhead abgezogen wurden.</li>
      <li>900 - 128 = 772 Kbit / s Video <code translate="No">decoder_bitrate_cap</code> nach dem Subtrahieren von 128 Kbit / s für das Audio.</li>
      <li>772 * 1,5 = 1158 Kb <code translate="No">decoder_buffer_size</code> (für Videos im Wert von 1,5 Sekunden).</li>
      <li>772 * 0,90 = 695 Kbit / s Zielvideobitrate (10% niedriger als die <code translate="No">decoder_bitrate_cap</code>).</li>
    </ul>
    <p>Für ein korrekteres Beispiel für eine Streaming-Codierung:</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "mp4-1000k",
        "prepare_for_segmenting": ["hls", "dash"],
        "audio_bitrate": 128,
        "decoder_bitrate_cap": 772,
        "decoder_buffer_size": 1158,
        "video_bitrate": 695,
        "url": "s3://mybucket/transmux-examples/sbr/video.mp4"
    },
    {
        "source": "mp4-1000k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/transmux-examples/sbr/hls/video.m3u8"
    },
    {
        "source": "mp4-1000k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/transmux-examples/sbr/dash/video.mpd"
    }
    ]
}</code></pre>

    <aside class="bcls-aside bcls-aside--information">Hinweis: Das obige ist <strong>nicht</strong> Ausreichend, um sicherzustellen, dass die HLS-Codierung die Validierung von Apple besteht. Während es bei einer 1000-Kbit / s-Verbindung nahtlos streamen würde, misst Apple die Bitraten pro Segment (einschließlich des letzten Segments, das möglicherweise eine kurze Dauer hat), ohne die Pufferungsaspekte zu berücksichtigen. Um sicherzustellen, dass HLS die Validierung von Apple codiert, lesen Sie unseren HLS-Handbuch.</aside>
  </section>
  <section class="bcls-section">
    <h2 id="Putting_it_all_together">Alles zusammenfügen</h2>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "mp4-1500k",
        "prepare_for_segmenting": ["hls", "dash"],
        "audio_bitrate": 128,
        "decoder_bitrate_cap": 1222,
        "decoder_buffer_size": 1833,
        "video_bitrate": 1100,
        "size": "1280x720",
        "url": "s3://mybucket/full-examples/mp4/1500.mp4"
    },
    {
        "label": "mp4-1000k",
        "prepare_for_segmenting": ["hls", "dash"],
        "audio_bitrate": 128,
        "decoder_bitrate_cap": 772,
        "decoder_buffer_size": 1158,
        "video_bitrate": 695,
        "size": "960x540",
        "url": "s3://mybucket/full-examples/mp4/1000.mp4"
    },
    {
        "label": "mp4-500k",
        "prepare_for_segmenting": ["hls", "dash"],
        "audio_bitrate": 128,
        "decoder_bitrate_cap": 322,
        "decoder_buffer_size": 483,
        "video_bitrate": 290,
        "size": "640x360",
        "url": "s3://mybucket/full-examples/mp4/500.mp4"
    },
    {
        "label": "hls-1500k",
        "source": "mp4-1500k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/full-examples/hls/1500.m3u8"
    },
    {
        "label": "hls-1000k",
        "source": "mp4-1000k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/full-examples/hls/1000.m3u8"
    },
    {
        "label": "hls-500k",
        "source": "mp4-500k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/full-examples/hls/500.m3u8"
    },
    {
        "type": "playlist",
        "url": "s3://mybucket/full-examples/hls/multi_bitrate_playlist.m3u8",
        "streams": [
        { "path": "1000.m3u8", "source": "hls-1000k" },
        { "path": "1500.m3u8", "source": "hls-1500k" },
        { "path": "500.m3u8", "source": "hls-500k" }
        ]
    },
    {
        "label": "dash-1500k",
        "source": "mp4-1500k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/full-examples/dash/1500k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "label": "dash-1000k",
        "source": "mp4-1000k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/full-examples/dash/1000k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "label": "dash-500k",
        "source": "mp4-500k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/full-examples/dash/500k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "streaming_delivery_format": "dash",
        "type": "playlist",
        "url": "s3://mybucket/full-examples/dash/manifest.mpd",
        "streams": [
            { "source": "dash-1500k", "path": "1500k" },
            { "source": "dash-1000k", "path": "1000k" },
            { "source": "dash-500k",  "path": "500k" }
        ],
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0",
            "schemas": [
                { "type": "marlin" },
                { "type": "playready", "license_acquisition_url": "https://playready.example.com/license_server/" }
            ]
        }
    }
    ]
}</code></pre>
  </section>
</article>